<head>
    <style>
        body {
            background-color: #222;
            font-family: "Lato", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            color: #fff;
        }

        input {
            resize: none;
            background-color: #375a7f;
            color: #fff;
            border: 0px;
            font-family: inherit;
            padding-left: 2px;
        }

        select {
            background-color: #375a7f;
            color: #fff;
            border: 0px;
            width: 20%;
        }

        button {
            font-family: inherit;
            font-size: inherit;
        }

        button.fieldTitle {
            width: 100%;
        }

        .disclaimer {
            text-align: center;
            margin: auto;
        }

        .disclaimer>.accordion {
            width: auto;
        }

        .multioption {
            display: inline-flex !important;
            position: relative;
        }

        .multioption.selected {
            background-color: #00bc8c;
        }

        .multioption .fieldTitle {
            width: auto;
        }

        .multioption input[type=checkbox] {
            opacity: 0;
            position: absolute;
            cursor: inherit;
        }

        .tabs {
            height: 8%;
        }

        .tab {
            width: 20% !important;
            text-align: center !important;
            height: 100%;
            font-size: 1.5em;
        }

        .tabcontent {
            display: none;
            background-color: #28415b;
            padding: 5px;
            transition: 0.4s;
            height: 90%;
            overflow-y: auto;
        }

        .accordion {
            background-color: #375a7f;
            color: #fff;
            cursor: pointer;
            padding: 5px;
            width: 100%;
            text-align: left;
            border: none;
            outline: none;
            transition: 0.4s;
        }

        .active,
        .accordion:hover {
            background-color: #28415b;
        }

        .panel {
            display: none;
            margin-left: 10px;
            padding: 2px 2px;
        }

        .charContainer {
            display: flex;
        }

        .charList {
            display: grid;
            height: 100%;
            width: 10%;
        }

        .charDesc {
            display: block;
            width: 90%;
            height: 100%;
            overflow-y: auto;
        }

        .fieldEntry {
            display: flex;
            width: auto !important;
        }

        .fieldEntry fieldset {
            margin: unset;
            border: unset;
            padding: unset;
            width: 80%;
        }

        .fieldTitle {
            width: 20%;
            font-family: "Lato", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            color: #fff;
            font-size: 1em;
        }

        .addRemoveButtons {
            display: flex;
        }

        .addRemoveButton {
            width: 1em;
            text-align: center;
        }
    </style>
    <script>
        var editorVersion = "9";
        var gameVersion = "0.0.11";

        var globals = {
            Class: { list: ["None", "Warrior", "Thief", "White Mage", "Black Mage", "Charmer"] },
            Background: { list: ["None", "Noble", "Minstrel", "Soldier", "Arcanist", "Barbarian", "Scholar", "Slumrat", "Acolyte", "Hunter", "Courtesan"] },
            // Slutty = 1
            Comp: { toSave: n => n - 1, fromSave: n => n + 1, list: ["Slutty", "Aggresive", "Reserved", "Playful", "Chaste"] },
            Affinity: { list: ["Strength", "Toughness", "Agility", "Cunning", "Willpower", "Presence"] },
            Power: { list: ["None", "At Will", "Recharge", "Encounter", "Ultimate"] },
            PowerTag: { list: ["Weapon", "Melee", "Ranged", "Thrown", "Spell", "Stance", "Summon", "Healing", "Ally", "Omni", "Performance", "Tease", "Tease Ass", "Tease Crotch", "Tease Chest"] },
            // AnyCock = -1, NormalTits = -16
            Pref: { toSave: n => -(n + 1), fromSave: n => -(n + 1), list: ["Any Cock", "No Cock", "Small Cock", "Big Cock", "Multi Cock", "Any Tits", "No Tits", "Small Tits", "Big Tits", "Vagina", "No Vagina", "Milk", "No Milk", "Big Ass", "Small Ass", "Normal Cock", "Normal Tits"] },
            Perk: { list: ["None", "Class", "Story", "Sex"] },
            Item: { list: ["None", "Weapon", "Armor Set", "Head", "Neck", "Shoulders", "Hands", "Waist", "Feet", "Ring", "Top Garb", "Botttom Garb", "Shield"] },
            ItemTag: { list: ["Two Hand", "Heavy", "Light", "Bladed", "Thrown", "Ranged", "Melee", "Implement/Catalyst", "Shield", "Skimpy", "Skin Tight", "Metal", "Leather", "Cloth", "Warded", "Calming", "Exp Chest", "Exp Crotch", "Exp Ass", "Conceal"] },
            Damage: { list: ["Raw", "Penetrating", "Crushing", "Holy", "Blight", "Acid", "Fire", "Frost", "Storm", "Tease", "Drug", "Pheromone", "Fatigue", "Mind"] },
            Attack: { list: ["None", "Physical", "Magical", "Mental", "Sexual"] },
            // None = -1
            BodyType: { toSave: n => n - 1, fromSave: n => n + 1, list: ["None", "Unspecified", "Human", "Orc", "Canine", "Feline", "Sylvan/Elf", "Equine", "Vulpine", "Snake", "Mothrine", "Goat", "Swine", "Shark", "Bee", "Draconic", "Kangaroo", "Anemone", "Avian", "Tentacle", "Demonic", "Frog", "Gooey", "Bovine", "Lupine", "Mouse", "Sheep", "Lapine", "Arachnid", "Succubus", "Dove"] },
            BodyTag: { list: ["Internal", "Knotted", "Gooey", "Tapered", "Flared", "Blunt", "Prehensile", "Stinger Based", "Stinger Tipped", "Nubby", "Amorphous", "Smooth", "Ribbed", "Foreskinned", "Double Headed", "Thick", "Sticky", "Fluffy", "Lubricated", "Long", "Hollow", "Squishy", "Angular", "Freckled", "Muzzled", "Beak", "Furred", "Tusked", "Refined", "Scaled", "Feathered", "Chitinous", "Aphrodisiac Laced", "Paws", "Digitigrade", "Plantigrade", "Heels", "Hooves", "Sheathed", "Pumped", "Slightly Pumped", "Spiked"] },
            // None = -1
            FluidType: { toSave: n => n - 1, fromSave: n => n + 1, list: ["None", "Unspecified", "Girlcum", "Cum", "Honey", "Milk", "Chocolate Milk", "Strawberry Milk"] },
            // None = -1
            SkinType: { toSave: n => n - 1, fromSave: n => n + 1, list: ["None", "Unspecified", "Latex", "Plant", "Bark", "Fur", "Feathers", "Skin", "Scales", "Chitin", "Goo"] },
            // None = -1
            NippleType: { toSave: n => n - 1, fromSave: n => n + 1, list: ["None", "Unspecified", "Fuckable", "Flat", "Inverted", "Lipples", "Tentacled", "Dick", "Normal"] },
            // None = -1
            HairType: { toSave: n => n - 1, fromSave: n => n + 1, list: ["None", "Unspecified", "Hair", "Plant", "Quills", "Feathers", "Goo", "Tentacles", "Transparent"] },
            Weapons: { list: ["None", "CaitsStaff", "Fist", "ShortSword", "CurvedBlade", "Spear", "Pike", "Poleaxe", "Battleaxe", "Francisca", "Javelin", "Quarterstaff", "BladeStaff", "HuntingBow", "WarBow", "Sling"] },
            ArmorSet: { list: ["None", "ComfortableClothes", "ScaleArmor", "MailCuirass", "Breastplate", "ApprenticeRobes", "LeatherJerkin", "LeatherCoat", "PassionPriestessGarb"] },
            ItemHead: { list: ["None"] },
            ItemNeck: { list: ["None", "WardAmulet"] },
            ItemShoulders: { list: ["None", "FlameCape", "PriestessCloak"] },
            ItemHands: { list: ["None", "Gauntlets", "ArmGuards", "SilverBracelets"] },
            ItemWaist: { list: ["None", "PotionBelt"] },
            ItemFeet: { list: ["None", "CaitsKneeBoots", "LeatherBoots", "IronGreaves"] },
            Rings: { list: ["None", "WizardRing"] },
            TopGarb: { list: ["None"] },
            BottomGarb: { list: ["None"] },
            Shields: { list: ["None", "HoplonShield", "TowerShield", "WickerShield"] },
            Powers: { list: ["AssTease", "CrotchTease", "ChestTease", "GuardedStance", "SpiritVeil", "BolsteringDance", "Heal", "SmokeBomb", "Allure", "PocketSand", "TaintedBulwark", "ThunderStrike", "PussyTailTease", "LustfulImages", "BlightOrb", "WhiteFire", "WitheringBolt", "LightningSpike", "WarSong", "SummonFlameSpirit", "NormalAttack", "Rend", "FadingStrike", "DirtyTrick", "BleedingCut"] },
            Perks: { list: ["MessyOrgasm", "Reserved", "Libidinous", "Milky", "Sterile", "Breeder", "SizeMonarch", "Stretchy", "Buxom", "WellHung"] },
            Items: { list: [] }
        };
        globals.Items.list = [].concat(
            globals.Weapons.list,
            globals.ArmorSet.list,
            globals.ItemHead.list,
            globals.ItemNeck.list,
            globals.ItemShoulders.list,
            globals.ItemHands.list,
            globals.ItemWaist.listt,
            globals.ItemFeet.list,
            globals.Rings.list,
            globals.TopGarb.list,
            globals.BottomGarb.list,
            globals.Shields.list
        ).filter(v => v !== "None");

        /*
            all
                label - The display name of the variable
                desc - A description of the variable
                type - Varialbe type (boolean, number, string, array, object, multioption)
                options - List of names or numbers that the variable can be
                groupTag - The display group the variable is part of
            array
                properties - The properties of each array entry
                min - The minimum size of the array
                max - The maximum size of the array
            multioption
                customCallback - Callback function used to change the output
            object
                properties - The properties of the object
                canBeNull - Can the value be null
                create - Function to create a new value
            string
            boolean
            number
                default - The default value if it doesn't exist
        */

        var charMap = {
            "name": { label: "Name", type: "string" },
            "class": { label: "Class", type: "number", options: globals.Class },
            "background": { label: "Background", type: "number", options: globals.Background },
            "genderPref": { label: "Gender Pref", type: "number" },
            "level": { label: "Level", type: "number" },
            "exp": { label: "Exp", type: "number" },
            "hitPoints": { label: "HP", type: "number", groupTag: "Stats", default: 100 },
            "hitPointsMaxMod": { label: "HP Max Mod", type: "number", groupTag: "Stats" },
            "resolvePoints": { label: "Resolve Points", type: "number", groupTag: "Stats" },
            "resolveMaxMod": { label: "Resolve Points Max Mod", type: "number", groupTag: "Stats" },
            "threatMod": { label: "Threat Mod", type: "number", groupTag: "Stats", default: 10 },
            "strengthAlloc": { label: "Strength", type: "number", groupTag: "Stats" },
            "strengthMod": { label: "Strength Mod", type: "number", groupTag: "Stats" },
            "toughnessAlloc": { label: "Toughness", type: "number", groupTag: "Stats" },
            "toughnessMod": { label: "Toughness Mod", type: "number", groupTag: "Stats" },
            "agilityAlloc": { label: "Agility", type: "number", groupTag: "Stats" },
            "agilityMod": { label: "Agility Mod", type: "number", groupTag: "Stats" },
            "cunningAlloc": { label: "Cunning", type: "number", groupTag: "Stats" },
            "cunningMod": { label: "Cunning Mod", type: "number", groupTag: "Stats" },
            "willpowerAlloc": { label: "Willpower", type: "number", groupTag: "Stats" },
            "willpowerMod": { label: "Willpower Mod", type: "number", groupTag: "Stats" },
            "presenceAlloc": { label: "Presence", type: "number", groupTag: "Stats" },
            "presenceMod": { label: "Presence Mod", type: "number", groupTag: "Stats" },
            "libidoMod": { label: "Libido Mod", type: "number", groupTag: "Stats" },
            "corruptionMod": { label: "Corruption Mod", type: "number", groupTag: "Stats" },
            "penetratingResist": { label: "Penetrating", type: "number", groupTag: "Stats.Resistance" },
            "crushingResist": { label: "Crushing", type: "number", groupTag: "Stats.Resistance" },
            "holyResist": { label: "Holy", type: "number", groupTag: "Stats.Resistance" },
            "blightResist": { label: "Blight", type: "number", groupTag: "Stats.Resistance" },
            "acidResist": { label: "Acid", type: "number", groupTag: "Stats.Resistance" },
            "fireResist": { label: "Fire", type: "number", groupTag: "Stats.Resistance" },
            "frostResist": { label: "Frost", type: "number", groupTag: "Stats.Resistance" },
            "stormResist": { label: "Storm", type: "number", groupTag: "Stats.Resistance" },
            "teaseResist": { label: "Tease", type: "number", groupTag: "Stats.Resistance" },
            "drugResist": { label: "Drug", type: "number", groupTag: "Stats.Resistance" },
            "pheromoneResist": { label: "Pheromone", type: "number", groupTag: "Stats.Resistance" },
            "fatigueResist": { label: "Fatigue", type: "number", groupTag: "Stats.Resistance" },
            "mindResist": { label: "Mind", type: "number", groupTag: "Stats.Resistance" },
            "raceAffinities": { label: "Race", type: "multioption", options: globals.Affinity, groupTag: "Affinities" },
            "classAffinities": { label: "Class", type: "multioption", options: globals.Affinity, groupTag: "Affinities" },
            "backgroundAffinities": { label: "Background", type: "multioption", options: globals.Affinity, groupTag: "Affinities" },
            "perks": {
                label: "Perks",
                type: "array",
                groupTag: "Effects",
                properties: {
                    type: "object",
                    create: createPerk,
                    canBeNull: false,
                    properties: {
                        "key": { label: "Key", type: "string" },
                        "values": { label: "Values", type: "array", properties: { type: "number" }, min: 6 }
                    }
                }
            },
            "powers": {
                label: "Powers",
                type: "multioption",
                options: globals.Powers,
                groupTag: "Effects",
                customCallback: (obj, key) => {
                    return (evnt) => {
                        var fieldset = evnt.currentTarget;
                        var list = Array.from(fieldset.getElementsByTagName("input")).filter(el => el.checked).map(el => el.name);
                        obj[key] = list;
                    }
                }
            },
            "equippedPowers": {
                label: "Equipped Powers",
                type: "multioption",
                options: globals.Powers,
                groupTag: "Effects",
                customCallback: (obj, key) => {
                    return (evnt) => {
                        var fieldset = evnt.currentTarget;
                        var list = Array.from(fieldset.getElementsByTagName("input")).filter(el => el.checked).map(el => el.name);
                        if (list.length > 5 && evnt.srcElement.type === "checkbox" && !evnt.srcElement.parentElement.classList.contains("selected")) {
                            evnt.srcElement.parentElement.classList.add("selected");
                            evnt.srcElement.checked = false;
                        }
                        else {
                            obj[key] = list;
                        }
                        obj[key].length = 5;
                    }
                }
            },
            "combatEffects": {
                label: "Combat",
                type: "array",
                groupTag: "Effects",
                properties: {
                    type: "object",
                    create: createCombatEffect,
                    canBeNull: false,
                    properties: {
                        "name": { label: "Name", type: "string" },
                        "short": { label: "Short", type: "string" },
                        "desc": { label: "Desc", type: "string" },
                        "duration": { label: "Duration", type: "number" },
                        "values": { label: "Values", type: "array", properties: { type: "number" } }
                    }
                }
            },
            "statusEffects": {
                label: "Status",
                type: "array",
                groupTag: "Effects",
                properties: {
                    type: "object",
                    create: createStatusEffect,
                    canBeNull: false,
                    properties: {
                        "name": { label: "Name", type: "string" },
                        "desc": { label: "Desc", type: "string" },
                        "duration": { label: "Duration", type: "number" },
                        "values": { label: "Values", type: "array", properties: { type: "number" } }
                    }
                }
            },
            "likes": { label: "Likes", type: "multioption", options: globals.Pref },
            "dislikes": { label: "Disikes", type: "multioption", options: globals.Pref },
            "credits": { label: "Credits", type: "number" },
            "weaponPrimary": { label: "Primary Weapon", type: "string", options: globals.Weapons, groupTag: "Equipment" },
            "weaponSecondary": { label: "Secondary Weapon", type: "string", options: globals.Weapons, groupTag: "Equipment" },
            "head": { label: "Head", type: "string", options: globals.ItemHead, groupTag: "Equipment" },
            "neck": { label: "Neck", type: "string", options: globals.ItemNeck, groupTag: "Equipment" },
            "shoulders": { label: "Shoulders", type: "string", options: globals.ItemShoulders, groupTag: "Equipment" },
            "armorSet": { label: "Armor Set", type: "string", options: globals.ArmorSet, groupTag: "Equipment" },
            "hands": { label: "Hands", type: "string", options: globals.ItemHands, groupTag: "Equipment" },
            "waist": { label: "Waist", type: "string", options: globals.ItemWaist, groupTag: "Equipment" },
            "feet": { label: "Feet", type: "string", options: globals.ItemFeet, groupTag: "Equipment" },
            "rings": { label: "Rings", type: "array", groupTag: "Equipment", properties: { type: "string", options: globals.Rings }, min: 2, max: 2 },
            "topGarment": { label: "Top Garment", type: "string", options: globals.TopGarb, groupTag: "Equipment" },
            "bottomGarment": { label: "Bottom Garment", type: "string", options: globals.BottomGarb, groupTag: "Equipment" },
            "inventory": { label: "Inventory", type: "array", properties: { type: "string", options: globals.Items } },
            "keyItems": { label: "Key Items", type: "array", properties: { type: "string" } },
            "originalRace": { label: "Original Race", type: "string", groupTag: "Appearance" },
            "femininity": { label: "Feminitity", type: "number", groupTag: "Appearance" },
            "tallness": { label: "Tallness", type: "number", groupTag: "Appearance" },
            "tone": { label: "Tone", type: "number", groupTag: "Appearance" },
            "thickness": { label: "Thickness", type: "number", groupTag: "Appearance" },
            "hipRatingRaw": { label: "Rating Raw", type: "number", groupTag: "Appearance.Hips" },
            "hipRatingMod": { label: "Rating Mod", type: "number", groupTag: "Appearance.Hips" },
            "buttRatingRaw": { label: "Rating Raw", type: "number", groupTag: "Appearance.Butt" },
            "buttRatingMod": { label: "Rating Mod", type: "number", groupTag: "Appearance.Butt" },
            "bellyRatingRaw": { label: "Rating Raw", type: "number", groupTag: "Appearance.Belly" },
            "bellyRatingMod": { label: "Rating Mod", type: "number", groupTag: "Appearance.Belly" },
            "lipMod": { label: "Mod", type: "number", groupTag: "Appearance.Lips" },
            "hairColor": { label: "Color", type: "string", groupTag: "Appearance.Hair" },
            "skinColor": { label: "Skin Color", type: "string", groupTag: "Appearance.Skin" },
            "furColor": { label: "Fur Color", type: "string", groupTag: "Appearance.Skin" },
            "scaleColor": { label: "Scale Color", type: "string", groupTag: "Appearance.Skin" },
            "lipColor": { label: "Color", type: "string", groupTag: "Appearance.Lips" },
            "hairLength": { label: "Length", type: "number", groupTag: "Appearance.Hair" },
            "hairStyle": { label: "Style", type: "string", groupTag: "Appearance.Hair" },
            "hairType": { label: "Type", type: "number", options: globals.HairType, groupTag: "Appearance.Hair" },
            "horns": { label: "Count", type: "number", groupTag: "Appearance.Horns" },
            "hornType": { label: "Type", type: "number", options: globals.BodyType, groupTag: "Appearance.Horns" },
            "hornLength": { label: "Length", type: "number", groupTag: "Appearance.Horns" },
            "wingType": { label: "Type", type: "number", options: globals.BodyType, groupTag: "Appearance.Wings" },
            "wingCount": { label: "Count", type: "number", groupTag: "Appearance.Wings" },
            "skinType": { label: "Type", type: "number", options: globals.SkinType, groupTag: "Appearance.Skin" },
            "skinTags": { label: "Tags", type: "multioption", options: globals.BodyTag, groupTag: "Appearance.Skin" },
            "tailType": { label: "Type", type: "number", options: globals.BodyType, groupTag: "Appearance.Tails" },
            "numTails": { label: "Count", type: "number", groupTag: "Appearance.Tails" },
            "tailTags": { label: "Tags", type: "multioption", options: globals.BodyTag, groupTag: "Appearance.Tails" },
            "armType": { label: "Type", type: "number", options: globals.BodyType, groupTag: "Appearance.Arms" },
            "armTags": { label: "Tags", type: "multioption", options: globals.BodyTag, groupTag: "Appearance.Arms" },
            "legCount": { label: "Count", type: "number", groupTag: "Appearance.Legs" },
            "legType": { label: "Type", type: "number", options: globals.BodyType, groupTag: "Appearance.Legs" },
            "legTags": { label: "Tags", type: "multioption", options: globals.BodyTag, groupTag: "Appearance.Legs" },
            "tongueType": { label: "Type", type: "number", options: globals.BodyType, groupTag: "Appearance.Tongue" },
            "tongueTags": { label: "Tags", type: "multioption", options: globals.BodyTag, groupTag: "Appearance.Tongue" },
            "faceType": { label: "Type", type: "number", options: globals.BodyType, groupTag: "Appearance.Face" },
            "faceTags": { label: "Tags", type: "multioption", options: globals.BodyTag, groupTag: "Appearance.Face" },
            "earType": { label: "Type", type: "number", options: globals.BodyType, groupTag: "Appearance.Ears" },
            "earTags": { label: "Tags", type: "multioption", options: globals.BodyTag, groupTag: "Appearance.Ears" },
            "earLength": { label: "Count", type: "number", groupTag: "Appearance.Ears" },
            "eyeType": { label: "Type", type: "number", options: globals.BodyType, groupTag: "Appearance.Eyes" },
            "eyeTags": { label: "Tags", type: "multioption", options: globals.BodyTag, groupTag: "Appearance.Eyes" },
            "eyeColor": { label: "Color", type: "string", groupTag: "Appearance.Eyes" },
            "orgasms": { label: "Orgasms", type: "number" },
            "lastOrgasm": { label: "Last Orgasm", type: "number" },
            "exhibRaw": { label: "Exhibition Raw", type: "number", groupTag: "Stats" },
            "isVirgin": { label: "Virgin", type: "boolean", groupTag: "Virginity" },
            "vaginalVirgin": { label: "Vaginal", type: "boolean", groupTag: "Virginity" },
            "cockVirgin": { label: "Cock", type: "boolean", groupTag: "Virginity" },
            "analVirgin": { label: "Anal", type: "boolean", groupTag: "Virginity" },
            "pregnancySpeedRaw": { label: "Speed Raw", type: "number", groupTag: "Pregnancy" },
            "pregnancySpeedMod": { label: "Speed Mod", type: "number", groupTag: "Pregnancy" },
            "breastRows": {
                label: "Row",
                type: "array",
                groupTag: "Breasts",
                min: 1,
                properties: {
                    type: "object",
                    canBeNull: false,
                    create: createBreastRow,
                    properties: {
                        "breasts": { label: "Count", type: "number" },
                        "type": { label: "Type", type: "number", options: globals.NippleType },
                        "tags": { label: "Tags", type: "multioption", options: globals.BodyTag },
                        "sizeRaw": { label: "Size Raw", type: "number" },
                        "sizeMod": { label: "Size Mod", type: "number" },
                        "lactationBonusMod": { label: "Lacation Bonus Mod", type: "number" },
                        "fullnessRaw": { label: "Fullness Raw", type: "number" },
                    }
                }
            },
            "nippleColor": { label: "Color", type: "string", groupTag: "Breasts.Nipples" },
            "nipplesPerBreast": { label: "Per Breast", type: "number", groupTag: "Breasts.Nipples" },
            "nippleLengthRatio": { label: "Length Ratio", type: "number", groupTag: "Breasts.Nipples" },
            "nippleWidthRatio": { label: "Width Ratio", type: "number", groupTag: "Breasts.Nipples" },
            "milkType": { label: "Type", type: "number", options: globals.FluidType, groupTag: "Breasts.Milk" },
            "milkMultiplier": { label: "Multiplier", type: "number", groupTag: "Breasts.Milk" },
            "milkStorageMultiplier": { label: "Storage Multiplier", type: "number", groupTag: "Breasts.Milk" },
            "milkFullness": { label: "Fullness", type: "number", groupTag: "Breasts.Milk" },
            "milkRate": { label: "Rate", type: "number", groupTag: "Breasts.Milk" },
            "balls": { label: "Count", type: "number", groupTag: "Balls" },
            "ballTags": { label: "Tags", type: "multioption", options: globals.BodyTag, groupTag: "Balls" },
            "ballEfficiency": { label: "Efficiency", type: "number", groupTag: "Balls" },
            "ballSizeRaw": { label: "Size Raw", type: "number", groupTag: "Balls" },
            "ballSizeMod": { label: "Size Mod", type: "number", groupTag: "Balls" },
            "ballFullness": { label: "Fullness", type: "number", groupTag: "Balls" },
            "cocks": {
                label: "Cocks",
                type: "array",
                properties: {
                    type: "object",
                    canBeNull: false,
                    create: createCock,
                    properties: {
                        "type": { label: "Type", type: "number", options: globals.BodyType },
                        "virgin": { label: "Virgin", type: "boolean" },
                        "tags": { label: "Tags", type: "multioption", options: globals.BodyTag },
                        "lengthRaw": { label: "Length Raw", type: "number" },
                        "lengthMod": { label: "Length Mod", type: "number" },
                        "thicknessRatioRaw": { label: "Thickness Ratio Raw", type: "number" },
                        "thicknessRatioMod": { label: "Thickness Ratio Mod", type: "number" },
                        "flaccidRatio": { label: "Flaccid Ratio", type: "number" },
                        "knotRatio": { label: "Knot Ratio", type: "number" },
                        "pierced": { label: "Pierced", type: "number" },
                        "color": { label: "Color", type: "string" },
                    }
                }
            },
            "feracityRaw": { label: "Feracity Raw", type: "number", groupTag: "Stats" },
            "feracityMod": { label: "Feracity Mod", type: "number", groupTag: "Stats" },
            "vagina": {
                label: "Vagina",
                type: "object",
                canBeNull: true,
                create: createVagina,
                properties: {
                    "type": { label: "Type", type: "number", options: globals.BodyType },
                    "hymen": { label: "Hymen", type: "boolean" },
                    "clits": { label: "Clits", type: "number" },
                    "color": { label: "Color", type: "string" },
                    "wetnessRaw": { label: "Wetness Raw", type: "number" },
                    "wetnessMod": { label: "Wetness Mod", type: "number" },
                    "loosenessRaw": { label: "Looseness Raw", type: "number" },
                    "loosenessMod": { label: "Looseness Mod", type: "number" },
                    "bonusCapacity": { label: "Bonus Capacity", type: "number" },
                    "stretchCounter": { label: "Stretch Counter", type: "number" },
                    "tags": { label: "Tags", type: "multioption", options: globals.BodyTag }
                }
            },
            "clitLength": { label: "Length", type: "number", groupTag: "Clit" },
            "girlCumType": { label: "Girl Cum Type", type: "number", options: globals.FluidType, groupTag: "Cum" },
            "cumType": { label: "Cum Type", type: "number", options: globals.FluidType, groupTag: "Cum" },
            "cumMultiplierRaw": { label: "Cum Multiplier Raw", type: "number", groupTag: "Cum" },
            "cumMultiplierMod": { label: "Cum Multiplier Mod", type: "number", groupTag: "Cum" },
            "ass": {
                label: "Butt",
                type: "object",
                canBeNull: false,
                create: createVagina,
                properties: {
                    "type": { label: "Type", type: "number", options: globals.BodyType },
                    "hymen": { label: "Hymen", type: "boolean" },
                    "clits": { label: "Clits", type: "number" },
                    "color": { label: "Color", type: "string" },
                    "wetnessRaw": { label: "Wetness Raw", type: "number" },
                    "wetnessMod": { label: "Wetness Mod", type: "number" },
                    "loosenessRaw": { label: "Looseness Raw", type: "number" },
                    "loosenessMod": { label: "Looseness Mod", type: "number" },
                    "bonusCapacity": { label: "Bonus Capacity", type: "number" },
                    "stretchCounter": { label: "Stretch Counter", type: "number" },
                    "tags": { label: "Tags", type: "multioption", options: globals.BodyTag }
                }
            },
            "title": { label: "Title", type: "string" },
        };

        //
        // Default create functions
        //

        function createCock() {
            return {
                type: 0,
                virgin: true,
                tags: [],
                lengthRaw: 5,
                lengthMod: 0,
                thicknessRatioRaw: 1,
                thicknessRatioMod: 0,
                flaccidRatio: .4,
                knotRatio: 1,
                pierced: 0,
                color: "pink"
            };
        }

        function createVagina() {
            return {
                type: 0,
                hymen: true,
                clits: 1,
                color: "pink",
                wetnessRaw: 1,
                wetnessMod: 0,
                loosenessRaw: 1,
                loosenessMod: 0,
                bonusCapacity: 0,
                stretchCounter: 0,
                tags: []
            };
        }

        function createBreastRow() {
            return {
                breasts: 2,
                type: 0,
                tags: [],
                sizeRaw: 0,
                sizeMod: 0,
                lactationBonusMod: 0,
                fullnessRaw: 0
            };
        }

        function createPerk() {
            return {
                key: "Not A Perk",
                values: [0, 0, 0, 0, 0]
            }
        }

        function createCombatEffect() {
            return {
                name: "Not A CombatEffect",
                short: "Not A CombatEffect",
                desc: "Not A CombatEffect",
                duration: 10000,
                values: [0, 0, 0, 0, 0]
            }
        }

        function createStatusEffect() {
            return {
                name: "Not A StatusEffect",
                desc: "Not A StatusEffect",
                duration: 0,
                values: [0, 0, 0, 0, 0]
            }
        }

        //
        // Create Elements
        //

        function createTextInput(initialValue, className, changeFunc) {
            var textAreaEl = document.createElement("input");
            textAreaEl.type = "text";
            textAreaEl.className = className;
            textAreaEl.value = initialValue;
            if (changeFunc)
                textAreaEl.addEventListener("change", changeFunc);
            return textAreaEl;
        }

        function createCheckBox(checked, className, changeFunc) {
            var checkBoxEl = document.createElement("input");
            checkBoxEl.className = className;
            checkBoxEl.checked = checked;
            checkBoxEl.type = "checkbox";
            if (changeFunc)
                checkBoxEl.addEventListener("change", changeFunc);
            return checkBoxEl;
        }

        function createPanel() {
            var panel = document.createElement("div");
            panel.className = "panel";
            return panel;
        }

        function createAccordButton(text, panelEl, onClickFunc, clearOtherTabs = false) {
            var accordButton = document.createElement("button");
            accordButton.innerText = text;
            accordButton.className = "accordion";
            accordButton.addEventListener("click", function accordClick() {
                if (this.className && clearOtherTabs) {
                    var otherTabs = this.parentElement.getElementsByClassName(this.className);
                    for (var i = 0; i < otherTabs.length; i++) {
                        otherTabs[i].className = otherTabs[i].className.replace(" active", "");
                    }
                }
                this.classList.toggle("active");
                if (panelEl) {
                    var panel = panelEl;
                    panel.style.display = panel.style.display === "none" || panel.style.display === "" ? "block" : "none";
                }
                if (onClickFunc)
                    onClickFunc(panel);
            });
            return accordButton;
        }

        //
        // On Click Top Tab Functions
        //

        function clearElement(el) {
            while (el.lastElementChild) {
                el.removeChild(el.lastElementChild);
            }
        }

        function generateCharList(obj, el) {
            var container = document.createElement("div");
            el.appendChild(container);
            container.className = "charContainer";
            var charList = document.createElement("div");
            container.appendChild(charList);
            charList.className = "charList";
            var charDesc = document.createElement("div");
            container.appendChild(charDesc);
            charDesc.className = "charDesc";
            Object.keys(obj.chars).forEach(function charKeys(key) {
                var charListEntry = createAccordButton(key, charDesc, function onClickCharDesc(panel) {
                    clearElement(panel);
                    var charKey = key;
                    if (!window.editObj)
                        alert("No Save loaded");
                    else if (!window.editObj.chars)
                        alert("No Characters in save");
                    else if (!window.editObj.chars[charKey])
                        alert("Character " + charKey + " not found");
                    else {
                        panel.style.display = "block";
                        generateMappedFields({}, Object.keys(charMap).reverse().map((key) => generateInfo(window.editObj.chars[charKey], key, panel, charMap)));
                    }
                }, true);
                charListEntry.className += " charListEntry";
                charList.appendChild(charListEntry);
            });
        }

        function onClickCharTab(panel) {
            clearElement(panel);
            panel.style.display = "block";
            if (!window.editObj)
                alert("No Save File loaded");
            else
                generateCharList(window.editObj, panel);
        }

        function onClickFlagTab(panel) {
            clearElement(panel);
            panel.style.display = "block";
            if (!window.editObj)
                alert("No Save File loaded");
            else if (!window.editObj.flags)
                alert("No Flags in save file");
            else
                generateFields(window.editObj.flags, panel);
        }

        function onClickRawTab(panel) {
            clearElement(panel);
            panel.style.display = "block";
            if (!window.editObj)
                alert("No Save File loaded");
            else
                generateFields(window.editObj, panel);
        }

        function onClickLoadTab(panel) {
            panel.click();
        }

        function onClickSaveTab(panel) {
            if (fileReader) {
                panel.href = 'data:text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(saveObj()));
                panel.download = file.name;
                panel.click();
            }
            else {
                alert("No Save File loaded");
            }
        }

        //
        // File Reading and Object Loading/Saving
        //

        var file;
        var fileReader;
        function handleFiles(event) {
            if (!event.srcElement.files || event.srcElement.files.length === 0) {
                alert("Error in file loading");
            }
            file = event.srcElement.files[0];
            fileReader = new FileReader();
            fileReader.readAsText(file);
            fileReader.addEventListener("loadend", function () {
                var obj;
                try {
                    obj = JSON.parse(fileReader.result);
                }
                catch (e) {
                    console.error(e);
                    alert("Error parsing file");
                }
                if (obj) {
                    loadObj(obj);
                    alert("Load Complete");
                }
            });
            fileReader.addEventListener("error", function (evnt) {
                console.log(evnt);
                alert("Error reading file");
            });
        }

        function generateValue(mapValue) {
            if (mapValue.type === "object") return mapValue.create ? mapValue.create() : (mapValue.canBeNull ? null : {});
            if (mapValue.type === "multioption" || mapValue.type === "array") return [];
            if (mapValue.type === "number") return 0;
            if (mapValue.type === "string") return "";
            if (mapValue.type === "boolean") return false;
        }

        function applyMap(obj, map) {
            var queue = Object.keys(map).map(k => ({ obj: obj, key: k, map: map }));
            var key, obj, map;

            while (queue.length > 0) {
                var info = queue.pop();
                obj = info.obj;
                key = info.key;
                map = info.map;
                if (map[key]) {
                    map = map[key];
                }
                if (!obj[key]) {
                    obj[key] = generateValue(map);
                }
                if (map.type === "array" && map.min)
                    while (obj[key].length < map.min)
                        obj[key].push(generateValue(map.properties));
                if ((map.type === "object" || map.type === "array") && obj[key]) {
                    Object.keys(obj[key]).forEach(v => queue.push({ obj: obj[key], key: v, map: map.properties }));
                }
            }
        }

        function unpackSave(obj) {
            Object.keys(obj.chars).forEach(charKey => {
                applyMap(obj.chars[charKey], charMap);
            });
        }

        function loadObj(obj) {
            window.fileObj = obj;
            window.editObj = JSON.parse(JSON.stringify(obj));
            unpackSave(window.editObj);
            window.dupObj = JSON.parse(JSON.stringify(window.editObj));
        }

        function isObj(obj) {
            return typeof obj === "object" && obj !== null;
        }

        var noValue = { noValue: true };
        function diffObjects(orig, edit) {
            var diffObj = {};
            var queue = [{ orig: orig, edit: edit, depth: [] }];
            var info;
            while (queue.length > 0) {
                info = queue.pop();
                // console.log(JSON.stringify(info));
                if (isObj(info.orig) && isObj(info.edit)) {
                    Object.keys(info.orig).forEach(k => {
                        queue.push({ orig: info.orig[k], edit: info.edit[k], depth: [{ key: k, array: Array.isArray(info.orig[k]) }].concat(info.depth) })
                    });
                    Object.keys(info.edit).forEach(k => {
                        queue.push({ orig: info.orig[k], edit: info.edit[k], depth: [{ key: k, array: Array.isArray(info.edit[k]) }].concat(info.depth) })
                    });
                }
                else if (info.orig !== info.edit) {
                    var depthQueue = info.depth.slice();
                    var depthObj = diffObj;
                    var depthInfo;
                    while (depthQueue.length > 1) {
                        depthInfo = depthQueue.pop();
                        if (!depthObj[depthInfo.key]) {
                            if (depthInfo.array) {
                                depthObj[depthInfo.key] = [];
                            }
                            else depthObj[depthInfo.key] = {};
                        }
                        depthObj = depthObj[depthInfo.key];
                    }
                    depthInfo = depthQueue.pop();
                    depthObj[depthInfo.key] = info.edit === undefined ? noValue : info.edit;
                }
            }
            return diffObj;
        }

        function applyDiff(diff, dest) {
            var queue = [{ diff: diff, dest: dest, key: null, pdiff: null, pdest: null }];
            var info;
            while (queue.length > 0) {
                info = queue.pop();
                // console.log(JSON.stringify(info));
                if (info.diff === noValue) {
                    if (Array.isArray(info.pdest) && Array.isArray(info.pdiff))
                        info.pdest.splice(info.key, 1);
                    delete info.pdest[info.key];
                }
                else if (isObj(info.diff) && info.dest !== undefined) {
                    Object.keys(info.diff).forEach(k => {
                        queue.push({ diff: info.diff[k], dest: info.dest[k], key: k, pdiff: info.diff, pdest: info.dest })
                    });
                }
                else if (info.diff !== info.dest) {
                    info.pdest[info.key] = info.diff;
                }
            }
            return dest;
        }
        window.diff = () => diffObjects(window.dupObj, window.editObj);
        window.apply = () => applyDiff(window.diff(), JSON.parse(JSON.stringify(window.fileObj)));

        function saveObj() {
            return applyDiff(diffObjects(window.dupObj, window.editObj), JSON.parse(JSON.stringify(window.fileObj)));
        }

        //
        // Page creation
        //

        document.addEventListener("DOMContentLoaded", () => {
            var disclaimer = document.createElement("div");
            disclaimer.className = "disclaimer";
            disclaimer.innerHTML = "<h2>CoC2 Save Editor v" + editorVersion + "</h2><h4>For use with versions of CoC2 " + gameVersion + "+</h4><p>Disclaimer: Editing any saves may permanently mess up the save or cause unusual bugs or errors in the game. Edit at your own risk and remember to back up your saves.</p>";
            document.body.appendChild(disclaimer);

            var ok = document.createElement("button");
            ok.innerText = "Accept";
            ok.className = "accordion";
            disclaimer.appendChild(ok);

            ok.addEventListener("click", () => {
                while (document.body.lastChild) {
                    document.body.removeChild(document.body.lastChild);
                }

                var tabs = document.createElement("div");
                tabs.className = "tabs";
                document.body.appendChild(tabs);

                var content = document.createElement("div");
                content.className = "mainTabContent tabcontent";
                content.id = "mainContent";
                document.body.appendChild(content);

                var charTab = createAccordButton("Characters", content, onClickCharTab, true);
                charTab.className += " tab";
                tabs.appendChild(charTab);

                var flagTab = createAccordButton("Flags", content, onClickFlagTab, true);
                flagTab.className += " tab";
                tabs.appendChild(flagTab);

                var rawTab = createAccordButton("Raw", content, onClickRawTab, true);
                rawTab.className += " tab";
                tabs.appendChild(rawTab);

                var input = document.createElement("input");
                input.id = "load";
                input.type = "file";
                input.style.display = "none";
                input.addEventListener("change", handleFiles);
                var loadTab = createAccordButton("Load", input, onClickLoadTab, true);
                loadTab.className += " tab";
                loadTab.appendChild(input);
                tabs.appendChild(loadTab);

                var saveLink = document.createElement("a");
                saveLink.id = "saveLink";
                var saveTab = createAccordButton("Save", saveLink, onClickSaveTab, true);
                saveTab.className += " tab";
                saveTab.appendChild(saveLink);
                tabs.appendChild(saveTab);
            });
        });

        //
        // Set Callbacks
        //

        function setNumberCallback(obj, key, modFunc) {
            return (evnt) => { obj[key] = modFunc ? modFunc(evnt.srcElement.value) : +evnt.srcElement.value; }
        }

        function setStringCallback(obj, key) {
            return (evnt) => { obj[key] = evnt.srcElement.value; }
        }

        function setSelectorStringCallback(obj, key) {
            return (evnt) => { obj[key] = evnt.srcElement[+evnt.srcElement.value].innerText === "None" ? null : evnt.srcElement[+evnt.srcElement.value].innerText; }
        }

        function setBooleanCallback(obj, key) {
            return (evnt) => obj[key] = evnt.srcElement.checked;
        }

        function setMultiOptionCallback(obj, key, canSelectFunc) {
            return (evnt) => {
                if (evnt.currentTarget && evnt.currentTarget.type === "fieldset") {
                    var fieldset = evnt.currentTarget;
                    var list = Array.from(fieldset.getElementsByTagName("input")).filter(el => el.checked);
                    obj[key] = list.map(el => +el.value);
                }
            };
        }

        //
        // Fields
        //

        function fieldTitle(key) {
            var title = document.createElement("div");
            title.className = "fieldTitle";
            title.textContent = key;
            return title;
        }

        function fieldLabelNoInteract(key) {
            var entry = document.createElement("div");
            entry.className = "accordion fieldEntry";
            var title = fieldTitle(key);
            entry.appendChild(title);
            return entry;
        }

        function fieldLabel(key) {
            var entry = document.createElement("label");
            entry.className = "accordion fieldEntry";
            var title = fieldTitle(key);
            entry.appendChild(title);
            return entry;
        }

        function objectField(text, panel) {
            var accordButton = createAccordButton("", panel);
            var closed = "⬥ ", open = "⬦ ";
            accordButton.className += " fieldTitle";
            accordButton.innerText = closed + text;
            accordButton.addEventListener("click", function nameChanger() {
                this.innerText = this.innerText.startsWith(closed) ? this.innerText.replace(closed, open) : this.innerText.replace(open, closed);
            });
            return accordButton;
        }

        function stringField(name, initialValue, changeFunc) {
            var div = fieldLabel(name);
            var input = createTextInput(initialValue, "", changeFunc);
            div.appendChild(input);
            return div;
        }

        function booleanField(name, initialValue, changeFunc) {
            var div = fieldLabel(name);
            var input = createCheckBox(initialValue, "", changeFunc);
            div.appendChild(input);
            return div;
        }

        function selectField(name, initialValue, options, changeFunc) {
            var div = fieldLabel(name);
            var selector = document.createElement("select");
            options.list.forEach((value, index) => {
                var option = document.createElement("option");
                option.value = index;
                option.innerText = value;
                option.selected = (options.fromSave ? options.fromSave(initialValue) : initialValue) === index || initialValue === value;
                selector.appendChild(option);
            });
            selector.addEventListener("change", changeFunc);
            div.appendChild(selector);
            return div;
        }

        function multiOptionField(name, obj, key, mapValue, changeFunc) {
            var div = fieldLabelNoInteract(name);
            var fieldSetEl = document.createElement("fieldset");
            var options = mapValue.options
            fieldSetEl.addEventListener("click", mapValue.customCallback ? mapValue.customCallback(obj, key) : setMultiOptionCallback(obj, key));
            options.list.forEach((option, index) => {
                var selected = obj[key].reduce((prev, curr) => prev = prev || (index === curr), false);
                var label = fieldLabel(option);
                label.className += " multioption" + (selected ? " selected" : "");
                var checkbox = createCheckBox(selected, "superhide", function callback() {
                    this.parentElement.classList.toggle("selected");
                });
                checkbox.value = options.list.indexOf(option);
                checkbox.name = option;
                label.appendChild(checkbox);
                fieldSetEl.appendChild(label);
            });
            fieldSetEl.addEventListener("change", changeFunc);
            div.appendChild(fieldSetEl);
            return div;
        }

        function generateAddRemoveButtons(panel, addCallback, removeCallback) {
            var addRemoveButtons = document.createElement("div");
            addRemoveButtons.className = "addRemoveButtons";
            var add = document.createElement("div");
            add.innerText = "+";
            add.className = "addRemoveButton accordion";
            add.addEventListener("click", addCallback);
            var remove = document.createElement("div");
            remove.innerText = "–";
            remove.className = "addRemoveButton accordion";
            remove.addEventListener("click", removeCallback);
            addRemoveButtons.appendChild(add);
            addRemoveButtons.appendChild(remove);
            panel.appendChild(addRemoveButtons);
        }

        function generateInfo(obj, key, element, map) {
            return {
                obj: obj,
                key: key,
                element: element,
                map: map,
            }
        }

        function processInfo(tags, info) {
            var obj = info.obj;
            var key = info.key;
            var map = info.map;
            var parentElement = info.element;
            var label = key;

            if (map[key]) {
                map = map[key];
            }

            if (map.label) {
                label = map.label;
            }

            if (!obj[key]) {
                obj[key] = generateValue(map);
            }

            if (map.groupTag) {
                map.groupTag.split(".").reduce(function (parentTag, curTag) {
                    if (!parentTag[curTag]) {
                        var panel = createPanel();
                        parentElement.appendChild(objectField(curTag, panel));
                        parentElement.appendChild(panel);
                        parentTag[curTag] = panel;
                    }
                    parentElement = parentTag[curTag];
                    return parentTag[curTag];
                }, tags);
            }

            if (map.type === "multioption" && map.options) {
                parentElement.appendChild(multiOptionField(label, obj, key, map));
            }
            else if (map.type === "object" || map.type === "array") {
                var panel = createPanel();
                if (map.type === "object") {
                    if (map.canBeNull) {
                        generateAddRemoveButtons(panel,
                            function objectAddCallback(tags, parent, obj, key, map) {
                                return () => {
                                    if (obj[key] === null) {
                                        obj[key] = map.create ? map.create() : {};
                                        generateMappedFields(tags, Object.keys(map.properties).reverse().map((mapKey) => generateInfo(obj[key], mapKey, parent, map.properties)));
                                    }
                                }
                            }(tags, panel, obj, key, map),
                            function objectRemoveCallback(parent, obj, key, map) {
                                return () => {
                                    if (obj[key]) {
                                        while (parent.lastChild !== parent.firstChild) {
                                            parent.removeChild(parent.lastChild);
                                        }
                                        obj[key] = null;
                                    }
                                }
                            }(panel, obj, key, map)
                        );
                    }
                }

                if (map.type === "array") {
                    if (map.min)
                        while (obj[key].length < map.min) {
                            obj[key].push(generateValue(map.properties));
                        }

                    if (!(map.min && map.max && map.min === map.max)) {
                        generateAddRemoveButtons(panel,
                            function arrayAddCallback(tags, parent, obj, key, map) {
                                return () => {
                                    if (!map.max || (map.max && obj[key].length < map.max)) {
                                        generateMappedFields(tags, processInfo(tags, generateInfo(obj[key], obj[key].length, parent, map.properties)));
                                    }
                                }
                            }(tags, panel, obj, key, map),
                            function arrayRemoveCallback(parent, obj, key, map) {
                                return () => {
                                    if (obj[key]) {
                                        if (obj[key].length > (map.min ? map.min : 0)) {
                                            parent.removeChild(parent.lastChild);
                                            if (typeof obj[key].pop() === "object")
                                                parent.removeChild(parent.lastChild);
                                        }
                                    }
                                }
                            }(panel, obj, key, map)
                        );
                    }
                }
                parentElement.appendChild(objectField(label, panel, obj[key], map));
                parentElement.appendChild(panel);

                if (obj[key])
                    return Object.keys(obj[key]).reverse().map((objKey) => generateInfo(obj[key], objKey, panel, map.properties));
            }
            else if (map.type === "string") {
                if (map.options)
                    parentElement.appendChild(selectField(label, obj[key], map.options, setSelectorStringCallback(obj, key)));
                else
                    parentElement.appendChild(stringField(label, obj[key], setStringCallback(obj, key)));
            }
            else if (map.type === "number") {
                if (map.options)
                    parentElement.appendChild(selectField(label, obj[key], map.options, setNumberCallback(obj, key, map.options.toSave)));
                else
                    parentElement.appendChild(stringField(label, obj[key], setNumberCallback(obj, key)));
            }
            else if (map.type === "boolean") {
                parentElement.appendChild(booleanField(label, obj[key], setBooleanCallback(obj, key)));
            }
        }

        function generateMappedFields(tags, startInfo) {
            if (!startInfo)
                return;

            var queue = Array.isArray(startInfo) ? startInfo : [startInfo];
            var tags = tags ? tags : {};

            while (queue.length > 0) {
                var results = processInfo(tags, queue.pop());
                if (results)
                    queue = queue.concat(results);
            }
        }

        function generateFields(obj, element) {
            Object.keys(obj).forEach(function fieldKeys(key) {
                switch (typeof obj[key]) {
                    case "string": {
                        element.appendChild(stringField(key, obj[key], setStringCallback(obj, key)));
                        break;
                    }
                    case "number": {
                        element.appendChild(stringField(key, obj[key], setNumberCallback(obj, key)));
                        break;
                    }
                    case "boolean": {
                        element.appendChild(booleanField(key, obj[key], setBooleanCallback(obj, key)));
                        break;
                    }
                    case "object": {
                        if (obj[key] === null)
                            break;
                        var panel = createPanel();
                        element.appendChild(objectField(key, panel));
                        element.appendChild(panel);
                        generateFields(obj[key], panel);
                    }
                }
            });
        }
    </script>
</head>

<body>
</body>